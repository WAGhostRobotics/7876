#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     ultra,          sensorSONAR)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    jack,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*IR Floor Code (7876)
Lilia Heinold, Alex McKinley
Version info in GitHub tags/releases.
*/

#include "Standard_Drive.c";
#include "JoystickDriver.c";
bool inputWaitForStart();
int inputWaitSecs();

/*
Start splitting center goal
Drive forward 30in
Check IR
	If IR is present - Position 1
	If Not
		Drive backward
		Turn Left 45
		Drive forward 35
		Turn Right 90
		Check IR
			If IR is present - Position 2
			If Not (Position 3)
				Turn right 45
				Forward 36 in
*/
//WORKING 3:20 pm 11/21 - 7876
task main()
{
	eraseDisplay();
	bool i = inputWaitForStart();//check for wait for start
	wait1Msec(500);

	int waitSecs = inputWaitSecs();//Input wait seconds from display

	if(i)
	{
		waitForStart();
	}
	wait1Msec(waitSecs*1000);	//Wait based on the selected value

	driveInches(35,50,50);
	print(SensorValue[ir]);
	wait1Msec(500);
	if(SensorValue[ir] >= 4 && SensorValue[ir] <= 6){
		PlaySound(soundBeepBeep);
		turn(RIGHT,90);
		driveInches(12,50,50);
		turn(LEFT,90);
		driveInches(48,50,50);
	}
	else{
		driveInches(-20,50,50);
		turn(LEFT,45);
		driveInches(35);
		turn(RIGHT,90);
		print(SensorValue[ir]);
		wait1Msec(500);
		if(SensorValue[ir] >= 5 && SensorValue[ir] <= 5){
			PlaySound(soundBeepBeep);
			driveInches(-6,50,50);
			turn(RIGHT,45);
			driveInches(15,50,50);
			turn(LEFT,40);
			driveInches(48,100,100);
		}
		else{
			turn(RIGHT,35);
			driveInches(36,100,100);
		}
	}


}

bool inputWaitForStart() {
	bool select = true;
	eraseDisplay();
	while(nNxtButtonPressed != 3) {
		if(nNxtButtonPressed == 1) { //Right arrow
			select = !select;
			PlaySound(soundBlip);
			eraseDisplay();
			wait1Msec(500);
		}
		else if(nNxtButtonPressed == 2) {
			select = !select;
			PlaySound(soundBlip);
			eraseDisplay();
			wait1Msec(500);
		}
		if(select)
			print(a, 2);
		else
			print(b, 2);
	}
	PlaySound(soundBlip);
	return select;
}

int inputWaitSecs() {
	int waitSecs = 0;
	eraseDisplay();
	print(waitSecs);
	while(nNxtButtonPressed != 3) {
		if(nNxtButtonPressed == 1) { //Right arrow
			waitSecs++;
			PlaySound(soundBlip);
			eraseDisplay();
			print(waitSecs);
			wait1Msec(500);
		}
		else if(nNxtButtonPressed == 2) {
			if(waitSecs > 0)
			{
				waitSecs--;
			}
			PlaySound(soundBlip);
			eraseDisplay();
			print(waitSecs);
			wait1Msec(500);
		}
	}
	PlaySound(soundBlip);
	return waitSecs;
}
